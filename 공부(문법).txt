1. 화살표 함수 -  
중괄호 생략가능 중괄호가 없으면 retrun 자동적용
매개변수가 없으면 반드시 () 필요
매개변수가 하나면 괄호 생략 가능
객체 리턴할 때 ()필요함
💡 화살표 함수는 자신만의 this를 가지지 않음!
즉, 외부 스코프의 this를 "그대로 사용"함.

2. MAP - 배열을 반복하면서 각 요소를 꺼냄 그리고 콜백함수가 return한 값들로
이루어진 새 배열을 반환
const products = [
  { id: 1, name: "사과" },
  { id: 2, name: "바나나" }
];

const result = products.map((item) => {
  return item.name;
});
결과값 ["사과", "바나나"]

3. 배열 구조 분해할당 {}
const [count, setCount] = useState(0);
체의 키 이름과 변수가 동일하면 자동 매칭
순서 상관 없음 (배열과의 차이점!)

4. 객체 분해할당 {}
const user = {
  name: "철수",
  age: 20,
  address: "서울"
};

기존방식
const name = user.name;
const age = user.age;
구조분해
const { name, age } = user; // 키값으로 받는거
console.log(name); // "철수"
console.log(age);  // 20

🟦  함수 매개변수에서 바로 구조 분해 사용 (React에서 ㅈㄴ많이 씀)

예: props 받을 때

function UserCard({ name, age }) {
  return (
    <div>
      <p>{name}</p>
      <p>{age}</p>
    </div>
  );
}

여기서

function UserCard(props) {
  const { name, age } = props;
}

🎯 7. 요약 (초간단 버전)
문법          설명
{ a, b } = obj  key 이름으로 값 꺼냄
{ a: newName }  변수 이름 바꿔서 받기
{ a = 기본값 }  기본값 설정
{ a, ...rest }  나머지 값 묶어서 받기
함수 매개변수 구조 분해 React에서 props 받을 때 필수



5. SPEAD 문법 - 개념이랑 예제 봐야함
펼친다음에 데이터 수정하는거
const updated = products.map((p) =>
  p.id === id ? { ...p, cartCount: p.cartCount + 1 } : p
);

6. 객체 리터럴 {} - 그자리에서 만드는거 리턴같은게 아니라

7. filter, reduce
- filter 조건에 맞는 요소만 걸러서 새로운 배열 반환
const nums = [1, 2, 3, 4, 5];
const even = nums.filter(n => n % 2 === 0);
console.log(even);

- reduce 배열을 하나의 값으로 합쳐주는 함수
- 배열 전체를 순회하면서 하나의 값으로 만들어줌
arr.reduce((acc, cur) => {
  // acc = 누적값
  // cur = 현재 요소
}, 초기값);

const totalPrice = cart.reduce((acc, item) => {
  return acc + item.price * item.count;
}, 0);

8. 함수형 업데이트
🎯 네가 이해한 한 줄 정리 (그대로 뇌에 새겨도 됨)

✔ setState 콜백의 매개변수 = React가 주는 "최신 상태값"
✔ map 콜백의 매개변수 = JS가 주는 "배열 요소"
✔ setState의 prev는 함수형 업데이트에서만 사용됨

🧪 이걸 코드 흐름으로 시각화해볼게
setProducts((prev) => {      // prev = 최신 products 배열
  return prev.map((p) => {   // p = prev 안의 각 상품 객체
    if (p.id === id) {
      return { ...p, cartCount: p.cartCount + 1 };
    }
    return p;
  });
});

9. 리액트는 "반복문으로 컴포넌트를 만들 때" 각 요소가 서로 어떤 요소인지를 구분해야해
각 key는 각 항목의 고유값(절대 중북되면 안됨)

10 핵심 개념: React 컴포넌트는 인자를 하나만 받는다
<ProductList category={category} products={products} /> 이렇게 넘긴다고 치자
➡️ 실제 함수가 받는 인자는 props 객체 하나
예시:
function ProductList(props) {
    // props = { category: "야채", products: [...] }
}


11 컴포넌트 = 화면을 만드는 함수
props = 부모가 자식에게 넘기는 데이터
넘길 때: <Child name="철수" age={20} />
받을 때: function Child({ name, age }) { ... }

<Child
  title="상품"        // 문자열
  price={3000}        // 숫자
  isSale={true}       // 불린
  data={someObject}   // 객체
  addCart={handleAdd} // 함수도 가능!
/>


12. 자식 컴포넌트에서는 state를 직접 변경하면 안된다.. props는 읽기 전용파일 입니다.

13. 화살표 함수에서는 {} 를 쓰면 반드시 retrun 을 추가해야함 그래서 객체를 리턴할때는
({}) 써야함 배열은 그냥써도된다


14. truethy / falsy
JS에서 A || B는 이렇게 동작해:
A가 Truthy면 A를 반환하고
A가 Falsy면 B를 반환한다

JS에서 A && B 이 표현의 뜻은:
A가 Truthy면 B를 반환
A가 Falsy면 A를 그대로 반환

즉, "A가 참일 때만 B를 실행해!" 라는 의미로 많이 씀.

15. 동기 vs 비동기
동기 = 은행창구 1개
비동기 = 은행창구 n개 + 번호표시스템
js는 싱글스레드 기반이기떄문에 동기화라고 가정하고 setInterval을 2초를 주면 2초동안 아무고토 못함

16. 이벤트 핸들러 콜백함수
버튼이 클릭되면 그함수를실행해줌 이런걸 이벤트 핸들러 또는 콜백함수라고 부름

17. 객체를 리턴할때는 에로우 펑션은 ({}) 이런 구조해야함

